import random
import math
import os
import requests


def parse_data(file_content):   # 解析数据集
    lines = file_content.strip().split('\n')
    rows, columns = map(int, lines[0].split())  # 获取第一行内容
    costs = []  # 子集成本
    covered = []  # 子集覆盖的元素
    raw_data = []  # 保存每一行的原始内容

    for line in lines[1:]:
        parts = list(map(int, line.strip().split()))
        cost = parts[0]
        num_covered = parts[1]
        covered_rows = parts[2:]
        costs.append(cost)
        covered.append(covered_rows)
        raw_data.append(line.strip())  # 保存原始数据行

    return rows, columns, costs, covered, raw_data


def objective_function(x, costs, covered, rows):
    """计算当前解的目标函数值，加入约束违反的惩罚项"""
    total_cost = sum(costs[i] * x[i] for i in range(len(x)))  # 计算总成本
    coverage_count = [0] * rows  # 记录每个元素被覆盖的次数

    # 统计每个元素被覆盖的次数
    for i in range(len(x)):
        if x[i] == 1:
            for row in covered[i]:
                coverage_count[row - 1] += 1

    # 计算约束违反的惩罚项
    penalty = sum(abs(count - 1) for count in coverage_count) * 1e5  # 惩罚项
    # 统计违反约束的rotation个数
    constraint_violations = sum(1 for count in coverage_count if count != 1)
    return total_cost + penalty, constraint_violations


def generate_neighbor(x):
    """生成新解：随机翻转一个子集的状态"""
    neighbor = x.copy()
    index = random.randint(0, len(x) - 1)
    neighbor[index] = 1 - neighbor[index]  # 翻转选中子集的状态
    return neighbor


def simulated_annealing(rows, columns, costs, covered, raw_data, T0=100000, T_min=0.01, alpha=0.995, max_iter=50000):
    # 初始解（随机生成）
    x_current = [random.randint(0, 1) for _ in range(columns)]
    f_current, constraint_violations = objective_function(x_current, costs, covered, rows)

    # 初始化最佳解
    Xbest = x_current.copy()
    ebest = f_current
    best_constraint_violations = constraint_violations

    T = T0
    k = 0

    # 模拟退火主循环
    while T > T_min and k < max_iter:
        # 生成新解
        x_new = generate_neighbor(x_current)
        f_new, constraint_violations_new = objective_function(x_new, costs, covered, rows)

        # 计算能量差
        delta_f = f_new - f_current

        # 接受准则
        if delta_f < 0:
            # 如果新解更好，直接接受
            x_current = x_new
            f_current = f_new
            constraint_violations = constraint_violations_new
        else:
            # 如果新解较差，以一定概率接受
            P = math.exp(-delta_f / T)  # 接受概率
            if P > random.random():
                x_current = x_new
                f_current = f_new
                constraint_violations = constraint_violations_new

        # 更新最佳解
        if f_current < ebest:
            Xbest = x_current.copy()
            ebest = f_current
            best_constraint_violations = constraint_violations

        # 降温
        T = alpha * T
        k += 1  # 增加评估次数

    # 返回最佳解、最佳目标函数值、违反约束的rotation个数和原始数据
    return Xbest, ebest, best_constraint_violations, raw_data


def get_data():
    url = 'https://raw.githubusercontent.com/Gavin295/Evolutionary-Computation/refs/heads/main/data3.txt'
    response = requests.get(url)
    if response.status_code == 200:
        data = response.text
    else:
        raise Exception("Failed to fetch dataset.")
    return data


def main():
    if os.path.exists('/Users/bianjunjia/pycharmprojects/EC-Project/data3.txt'):
        with open('/Users/bianjunjia/pycharmprojects/EC-Project/data3.txt', 'r') as file:
            data = file.read()
            print("Dataset Loaded From Local Successfully!")
            rows, columns, costs, covered, raw_data = parse_data(data)
            best_cost = float('inf')
            best_solution = None
            best_constraint_violations = float('inf')

            solution, total_cost, constraint_violations, _=simulated_annealing(rows, columns, costs, covered, raw_data)

            best_solution = solution.copy()
            best_cost = total_cost
            best_constraint_violations = constraint_violations

            # 输出最终结果
            print("最终最优解：", best_solution)
            print("最终最小成本：", best_cost)
            print("违反约束的目标个数：", best_constraint_violations)
            print("\n被选中的集合内容：")
            for i, selected in enumerate(best_solution):
                if selected == 1:
                    print(raw_data[i])

    else:
        data = get_data()
        print("Dataset Loaded From Github Successfully!")
        rows, columns, costs, covered, raw_data = parse_data(data)
        best_cost = float('inf')
        best_solution = None
        best_constraint_violations = float('inf')

        solution, total_cost, constraint_violations, _ = simulated_annealing(rows, columns, costs, covered, raw_data)

        best_solution = solution.copy()
        best_cost = total_cost
        best_constraint_violations = constraint_violations

        print("最终最优解：", best_solution)
        print("最终最小成本：", best_cost)
        print("违反约束的目标个数：", best_constraint_violations)
        print("\n被选中的集合内容：")
        for i, selected in enumerate(best_solution):
            if selected == 1:
                print(raw_data[i])



if __name__ == "__main__":
    main()
